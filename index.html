<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kelvin Cells</title>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        overflow: hidden;
        font-family: Inter, Arial, sans-serif;
        background: radial-gradient(circle at 30% 10%, #23395b, #080d14 70%);
      }

      #game {
        display: block;
        width: 100vw;
        height: 100vh;
        cursor: crosshair;
      }

      .hud {
        position: fixed;
        inset: 0;
        pointer-events: none;
      }

      .reticle {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 14px;
        height: 14px;
        border: 2px solid #ffffffb0;
        border-radius: 50%;
        box-shadow: 0 0 8px #ffffff99;
      }

      .info {
        position: absolute;
        left: 16px;
        top: 16px;
        padding: 8px 12px;
        background: #00000088;
        border-radius: 10px;
        border: 1px solid #ffffff2a;
        line-height: 1.45;
      }

      .hotbar {
        position: absolute;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        padding: 8px;
        border-radius: 12px;
        background: #00000090;
        border: 1px solid #ffffff2a;
      }

      .slot {
        width: 64px;
        height: 64px;
        border-radius: 10px;
        border: 2px solid #ffffff33;
        display: grid;
        place-items: center;
        font-size: 14px;
        font-weight: 700;
        color: #eaf4ff;
        text-shadow: 0 2px 4px #000;
        position: relative;
        transition: transform 120ms ease;
      }

      .slot.active {
        border-color: #ffe08a;
        box-shadow: 0 0 12px #ffe08a66;
        transform: translateY(-2px);
      }

      .slot .count {
        position: absolute;
        right: 6px;
        bottom: 4px;
        font-size: 13px;
        font-weight: 800;
      }

      .help {
        position: absolute;
        right: 16px;
        top: 16px;
        max-width: 280px;
        padding: 8px 12px;
        border-radius: 10px;
        border: 1px solid #ffffff2a;
        background: #00000088;
        line-height: 1.45;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div class="hud">
      <div class="reticle"></div>
      <div class="info" id="info"></div>
      <div class="help">
        <strong>Controls</strong><br />
        Left Click: Break Kelvin cell<br />
        Right Click: Place cell<br />
        1-5 / Mouse Wheel: Select hotbar slot
      </div>
      <div class="hotbar" id="hotbar"></div>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const infoEl = document.getElementById("info");
      const hotbarEl = document.getElementById("hotbar");

      const TYPES = [
        { key: "basalt", name: "Basalt", color: "#5f6878", top: "#97a3b7" },
        { key: "amber", name: "Amber", color: "#7b4a20", top: "#d88c34" },
        { key: "jade", name: "Jade", color: "#1f6d54", top: "#4ec596" },
        { key: "glacier", name: "Glacier", color: "#3f5d9b", top: "#80b4ff" },
        { key: "obsidian", name: "Obsidian", color: "#3b2f5e", top: "#a497e3" },
      ];

      const world = new Map();
      const particles = [];
      const pickupBursts = [];
      const inventory = Object.fromEntries(TYPES.map((t) => [t.key, 0]));
      inventory.basalt = 12;
      inventory.amber = 8;

      let selected = 0;
      let hovered = null;
      let camera = { x: 0, y: 0 };
      const gridRadius = 11;
      const size = 34;
      const cellH = 16;
      const sqrt3 = Math.sqrt(3);

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      function keyFor(q, r) {
        return `${q},${r}`;
      }

      function axialDistance(q, r) {
        const s = -q - r;
        return Math.max(Math.abs(q), Math.abs(r), Math.abs(s));
      }

      function randomType() {
        return TYPES[Math.floor(Math.random() * TYPES.length)].key;
      }

      function generateWorld() {
        for (let q = -gridRadius; q <= gridRadius; q++) {
          for (let r = -gridRadius; r <= gridRadius; r++) {
            if (axialDistance(q, r) <= gridRadius && Math.random() > 0.1) {
              world.set(keyFor(q, r), { q, r, type: randomType(), hp: 1 });
            }
          }
        }
      }
      generateWorld();

      function getType(typeKey) {
        return TYPES.find((t) => t.key === typeKey);
      }

      function hexCenter(q, r) {
        const x = size * (1.5 * q) + canvas.width / 2 + camera.x;
        const y = size * (sqrt3 * (r + q / 2)) + canvas.height / 2 + camera.y;
        return { x, y };
      }

      function polyPoints(cx, cy, radius, sides = 8, rotate = Math.PI / 8) {
        const points = [];
        for (let i = 0; i < sides; i++) {
          const a = rotate + (Math.PI * 2 * i) / sides;
          const radial = i % 2 === 0 ? radius : radius * 0.82;
          points.push({ x: cx + Math.cos(a) * radial, y: cy + Math.sin(a) * radial });
        }
        return points;
      }

      function drawPoly(points, fill, stroke) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 1.2;
        ctx.stroke();
      }

      function drawCell(cell, isHovered) {
        const { x, y } = hexCenter(cell.q, cell.r);
        const type = getType(cell.type);

        const top = polyPoints(x, y - cellH, size * 0.72, 8);
        const base = polyPoints(x, y, size * 0.72, 8);

        for (let i = 0; i < base.length; i++) {
          const j = (i + 1) % base.length;
          const p1 = base[i];
          const p2 = base[j];
          const p3 = top[j];
          const p4 = top[i];
          const shade = i < base.length / 2 ? "22" : "44";
          drawPoly([p1, p2, p3, p4], `${type.color}${shade}`, "#00000030");
        }

        drawPoly(top, type.top, isHovered ? "#fff7b8" : "#ffffff40");

        if (isHovered) {
          ctx.beginPath();
          ctx.ellipse(x, y + 2, size * 0.66, size * 0.32, 0, 0, Math.PI * 2);
          ctx.strokeStyle = "#ffe08acc";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      function screenToAxial(mx, my) {
        const x = mx - canvas.width / 2 - camera.x;
        const y = my - canvas.height / 2 - camera.y;
        const q = ((2 / 3) * x) / size;
        const r = ((-1 / 3) * x + (sqrt3 / 3) * y) / size;
        return roundHex(q, r);
      }

      function roundHex(q, r) {
        let x = q;
        let z = r;
        let y = -x - z;

        let rx = Math.round(x);
        let ry = Math.round(y);
        let rz = Math.round(z);

        const xDiff = Math.abs(rx - x);
        const yDiff = Math.abs(ry - y);
        const zDiff = Math.abs(rz - z);

        if (xDiff > yDiff && xDiff > zDiff) rx = -ry - rz;
        else if (yDiff > zDiff) ry = -rx - rz;
        else rz = -rx - ry;

        return { q: rx, r: rz };
      }

      function explode(cell) {
        const { x, y } = hexCenter(cell.q, cell.r);
        const type = getType(cell.type);

        for (let i = 0; i < 36; i++) {
          const a = Math.random() * Math.PI * 2;
          const speed = 1 + Math.random() * 4.2;
          particles.push({
            x,
            y: y - cellH,
            vx: Math.cos(a) * speed,
            vy: Math.sin(a) * speed - 1,
            life: 30 + Math.random() * 24,
            color: Math.random() > 0.35 ? type.top : "#ffffff",
            size: 2 + Math.random() * 3,
          });
        }

        pickupBursts.push({ x, y: y - 10, text: `+1 ${type.name}`, life: 55, color: type.top });
      }

      function breakCell() {
        if (!hovered) return;
        const key = keyFor(hovered.q, hovered.r);
        const cell = world.get(key);
        if (!cell) return;
        explode(cell);
        inventory[cell.type] += 1;
        world.delete(key);
      }

      function placeCell() {
        if (!hovered) return;
        const chosen = TYPES[selected].key;
        if (inventory[chosen] < 1) return;
        const neighbors = [
          [1, 0],
          [0, 1],
          [-1, 1],
          [-1, 0],
          [0, -1],
          [1, -1],
        ];
        for (const [dq, dr] of neighbors) {
          const q = hovered.q + dq;
          const r = hovered.r + dr;
          const k = keyFor(q, r);
          if (!world.has(k) && axialDistance(q, r) <= gridRadius + 2) {
            world.set(k, { q, r, type: chosen, hp: 1 });
            inventory[chosen] -= 1;
            return;
          }
        }
      }

      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.08;
          p.vx *= 0.99;
          p.life -= 1;
          if (p.life <= 0) particles.splice(i, 1);
        }

        for (let i = pickupBursts.length - 1; i >= 0; i--) {
          const t = pickupBursts[i];
          t.y -= 0.4;
          t.life -= 1;
          if (t.life <= 0) pickupBursts.splice(i, 1);
        }
      }

      function renderParticles() {
        for (const p of particles) {
          ctx.globalAlpha = Math.max(0, p.life / 54);
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y, p.size, p.size);
        }
        ctx.globalAlpha = 1;

        for (const t of pickupBursts) {
          ctx.globalAlpha = Math.max(0, t.life / 55);
          ctx.fillStyle = t.color;
          ctx.font = "bold 18px Inter, sans-serif";
          ctx.fillText(t.text, t.x - 30, t.y);
        }
        ctx.globalAlpha = 1;
      }

      function renderHotbar() {
        hotbarEl.innerHTML = "";
        TYPES.forEach((type, idx) => {
          const slot = document.createElement("div");
          slot.className = `slot ${idx === selected ? "active" : ""}`;
          slot.style.background = `linear-gradient(140deg, ${type.top}, ${type.color})`;
          slot.innerHTML = `${idx + 1}<span class="count">${inventory[type.key]}</span>`;
          hotbarEl.appendChild(slot);
        });
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const cells = [...world.values()].sort((a, b) => a.q + a.r - (b.q + b.r));
        for (const cell of cells) {
          const isHovered = hovered && cell.q === hovered.q && cell.r === hovered.r;
          drawCell(cell, isHovered);
        }

        renderParticles();

        const activeType = TYPES[selected];
        infoEl.innerHTML = `
          <strong>KelvinCraft Prototype</strong><br>
          Selected: ${activeType.name} (${inventory[activeType.key]})<br>
          Cells in world: ${world.size}
        `;
        renderHotbar();
      }

      function loop() {
        updateParticles();
        render();
        requestAnimationFrame(loop);
      }

      canvas.addEventListener("mousemove", (e) => {
        hovered = screenToAxial(e.clientX, e.clientY);
        const candidate = world.get(keyFor(hovered.q, hovered.r));
        if (!candidate) hovered = null;
      });

      canvas.addEventListener("mousedown", (e) => {
        if (e.button === 0) breakCell();
      });

      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        placeCell();
      });

      canvas.addEventListener("wheel", (e) => {
        selected = (selected + (e.deltaY > 0 ? 1 : -1) + TYPES.length) % TYPES.length;
      });

      window.addEventListener("keydown", (e) => {
        const num = Number(e.key);
        if (num >= 1 && num <= TYPES.length) selected = num - 1;
      });

      loop();
    </script>
  </body>
</html>
